<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>
      Run your own mesh VPN and DNS with Tailscale and PiHole | shotor.com
    </title>
    <meta
      name="description"
      content="shotor.com blog | Run your own mesh VPN and DNS with Tailscale and PiHole"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="canonical"
      href="https://shotor.com/blog/run-your-own-mesh-vpn-and-dns-with-tailscale-and-pihole"
    />
    <script async defer data-website-id="7e8fe8b7-adee-446d-9d62-aabe3bf971f0" src="https://umami.shotor.io/umami.js"></script>
    <link
      href="https://fonts.googleapis.com/css?family=Work+Sans"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/style.css" />
    <link rel="stylesheet" href="/blog.css" />
    <link rel="stylesheet" href="/highlight.css" />
  </head>
  <body class="language-none">
    <main>
      <span><a href="/">back to home</a></span>
      <p>
        <h1>Run your own mesh VPN and DNS with Tailscale and PiHole</h1>
      </p>
      <p>
        I&#39;ve been using Tailscale for a while to connect all my devices
        together in a mesh network. I use it to access web applications running
        on one of my servers (home or remote), from any of my devices (phone,
        laptop, tablet). Tailscale makes this really easy. <a href="https://tailscale.com/download">Install it</a> on your
        devices and it will connect your devices together and
        assign them unique ip addresses. To see how it works, check out
        <a href="https://tailscale.com/blog/how-tailscale-works/"
          >their blog post
        </a>
        that goes in depth.
      </p>
      <p>
        Recently I wanted to add
        <a href="https://pi-hole.net/">PiHole</a> private DNS to my setup in
        order to increase security and privacy while browsing. And also to
        assign readable hostnames to each device. This way I don&#39;t have to
        memorize ip addresses or mess with local host files anymore.
      </p>
      <p>A simplified view of my setup:</p>
      <p><img src="./images/network.png" alt="Network Diagram" /></p>
      <p>
        We&#39;re going to run PiHole in a Docker container on it&#39;s own
        subnet. We&#39;ll expose this subnet on our network by turning one of
        our servers into a Tailscale subnet relay node. Finally, we&#39;ll set
        the DNS to be used by all our Tailscale devices through the
        Tailscale admin console.
      </p>
      <p>
        If you don&#39;t want to run your own DNS, but just want readable names
        for your devices. You can skip this guide and use
        <a href="https://tailscale.com/kb/1081/magic-dns"
          >Tailscale Magic DNS</a
        >
        instead. It automatically assigns fixed hostnames to all your devices.
        While it&#39;s a really cool feature, with PiHole you get more
        flexibility, as well as privacy and security features.
      </p>
      <h2 id="setting-up-pihole">Setting up PiHole</h2>
      <p>
        There are a few ways to setup PiHole. In this case I&#39;m running it
        with Docker on a remote server. But this guide also works if you&#39;re
        hosting PiHole directly. The important part is to have PiHole accessible
        on the Tailscale mesh network. To do this you can install Tailscale on
        the server running PiHole, or setup a subnet relay node (see next
        section).
      </p>
      <p>
        First I&#39;m going to create a new Docker bridge network, because I
        don&#39;t want bind ports from the Docker container to my host machine.
        This way I can host PiHole completely isolated on a separate internal
        IP, and use the default port for DNS (53).
      </p>
      <pre><code>docker network create \
  --driver=bridge \
  --subnet=172.21.0.0/16 \
  --gateway=172.21.0.1 \
  -o &quot;com.docker.network.bridge.name&quot;=&quot;docker-apps&quot; \
  -o &quot;com.docker.network.bridge.enable_ip_masquerade&quot;=&quot;true&quot; \
  -o &quot;com.docker.network.bridge.enable_icc&quot;=&quot;true&quot; \
  -o &quot;com.docker.network.driver.mtu&quot;=&quot;1500&quot; \
  apps</code></pre>
      <p>
        In my case I also had to allow this network to access the internet by
        modifying iptables.
      </p>
      <pre><code>sudo iptables -t nat -A POSTROUTING -s 172.21.0.0/16 -j MASQUERADE</code></pre>
      <p>
        Now we can run a new PiHole docker container on this network. I&#39;m
        also going to assign it a static IP address. That way we only have to
        configure it once as our DNS, and not every time the server
        restarts and the ip changes.
      </p>
      <pre><code>docker run -d \
    --name pihole \
    --network=apps \
    --ip=172.21.0.2 \
    -e TZ=&quot;Europe/Amsterdam&quot; \
    -v &quot;{{PATH_TO_STORE_PIHOLE_DATA}}/etc-pihole/:/etc/pihole/&quot; \
    -v &quot;{{PATH_TO_STORE_PIHOLE_DATA}}/etc-dnsmasq.d/:/etc/dnsmasq.d/&quot; \
    --dns=127.0.0.1 \
    --dns=1.1.1.1 \
    --restart=unless-stopped \
    --hostname pi.hole \
    -e VIRTUAL_HOST=&quot;pi.hole&quot; \
    -e PROXY_LOCATION=&quot;pi.hole&quot; \
    -e ServerIP=&quot;127.0.0.1&quot; \
    pihole/pihole:latest</code></pre>
      <p>
        Now we have a working instance of PiHole running on our server. The only
        problem is we can only access it on this particular machine, because it
        uses an internal IP address. Any other device on our mesh network
        can&#39;t access this IP, yet.
      </p>
      <h2 id="subnet-relay-node">Subnet Relay Node</h2>
      <p>
        With Tailscale we can expose internal ip addresses of a machine by
        turning the device into a
        <a href="https://tailscale.com/kb/1019/subnets">relay node</a>.
      </p>
      <p>
        We restart Tailscale and instruct it to advertise the subnet we want to
        expose on the network.
      </p>
      <pre><code>sudo tailscale up --advertise-routes=172.21.0.0/16</code></pre>
      <p>If you get errors, make sure IP forwarding is enabled.</p>
      <pre><code>echo &#39;net.ipv4.ip_forward = 1&#39; | sudo tee -a /etc/sysctl.conf
sudo sysctl -p /etc/sysctl.conf</code></pre>
      <p>
        Then for our host machine we disable key expiry and enable subnet
        routes.
      </p>
      <p>
        <img
          src="./images/key-expiry-subnet-routes.png"
          alt="Disable key expiry and enable subnet routes"
        />
      </p>
      <p>
        If everything went well you should see the subnet in the admin panel.
      </p>
      <p>
        <img src="./images/subnets-enabled.png" alt="Subnet routes enabled" />
      </p>
      <p>
        We can now access the subnet on any connected device. On Linux devices
        you&#39;ll have to enable this feature first:
      </p>
      <pre><code>sudo tailscale up --accept-routes</code></pre>
      <p>
        Now go to <a href="http://172.21.0.2">http://172.21.0.2</a> on any of
        your devices to see PiHole running. Pretty cool, right?
      </p>
      <h2 id="setting-the-dns-server-for-all-our-devices">
        Setting the DNS for all our devices
      </h2>
      <p>
        Exposing subnet routes is a really powerful feature. You can host
        applications on internal IP addresses on any of your servers, and access
        them directly from your devices - no port bindings or reverse proxying
        required.
      </p>
      <p>
        But we can take it a step further by using PiHole as the default DNS for
        all connected devices. Simply put: Turn Tailscale on, and you instantly
        have access to all your self-hosted apps using readable names, and your
        browsing expires becomes more secure.
      </p>
      <p>This part is very easy.</p>
      <p>
        In the Tailscale admin console, we&#39;re going to click on the DNS tab.
        And add our PiHole IP address as the DNS.
        <img src="./images/pihole-dns.png" alt="PiHole DNS" />
      </p>
      <p>
        That&#39;s it. All our devices are now configured to use PiHole as the
        primary DNS. You can see this by opening a website on a device and
        checking the logs in the PiHole UI. Or by checking the contents of the
        <code>/etc/resolv.conf</code> file.
      </p>
      <p>On Mac/Linux:</p>
      <pre><code>cat /etc/resolv.conf
# resolv.conf(5) file generated by tailscale
# DO NOT EDIT THIS FILE BY HAND -- CHANGES WILL BE OVERWRITTEN

nameserver 172.21.0.2</code></pre>
      <p>
        Note: We only configured 1 DNS. That brings the risk that if it goes
        down, you can&#39;t connect directly to any domain. The next step would
        be to run another PiHole instance on a different server within the
        network. This makes the DNS redundant and will avoid connection problems
        in case one of the nodes goes down. Another option is to log in to the
        Tailscale admin console and turn off the DNS feature.
      </p>
      <h2 id="next-steps">Next Steps</h2>
      <p>Some things to consider doing next:</p>
      <ul>
        <li>
          Setup readable names for your apps. Click on
          <strong>Local DNS Records</strong> in the PiHole UI and start mapping
          your ip addresses. How about pi.hole to access the PiHole UI?
        </li>
        <li>
          Add new block lists to block more ads, trackers and malware,
          <a href="https://hosts.oisd.nl/">this one</a> is quite popular.
        </li>
        <li>
          Run a second instance of PiHole, in case one malfunctions, and add it
          as the secondary DNS.
          <a href="https://github.com/vmstan/gravity-sync">Gravity-sync</a> can
          help with synchronization of the PiHole instances.
        </li>
        <li>
          Add your home router to the mesh network, so any device connected to
          your router automatically uses PiHole. Note: you&#39;ll probably want
          a second instance of PiHole instance on a different server.
        </li>
        <li>
          Run some more apps.
          <a href="https://hub.docker.com/r/linuxserver/calibre">Here</a>
          <a href="https://hub.docker.com/r/gitea/gitea">are</a>
          <a href="https://hub.docker.com/r/linuxserver/syncthing">some</a>
          <a href="https://hub.docker.com/r/linuxserver/code-server">cool</a>
          <a href="https://github.com/awesome-selfhosted/awesome-selfhosted"
            >ones</a
          >.
        </li>
        <li>
          Wait a couple of days and see how much traffic PiHole has managed to
          block. I&#39;ve been running PiHole for a couple of days and it blocks
          around 20% of all the DNS requests made.
        </li>
      </ul>
    </main>

    <script src="/highlight.js"></script>
  </body>
</html>
